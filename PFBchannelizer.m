function PFBchannelizer(filename_in, nseries, os_factor, verbose_, diagnostic_plots_)
%
% Takes as input a data file generated by "signalgen.m", passes it through
% a polyphase filterbank (PFB) channelizer, then stores the output of one
% channel to file.  The type of PFB is selectable: either critically
% sampled or oversampled. The number of PFB channels is selectable.
% The PFB prototype filter is designed separately and its coefficients
% provided in a file.
%
% Inputs:
% -------
%
% filename_in  - Input filename
% headerFile - A dada-style pulsar signal header file
% fname_pfb - PFB prototype filter coefficients filename
%
% SETTINGS
%
% hdrsize   - Header size
% hdrtype   - Data type for header ('uint8' = byte)
% ntype     - Data type for each element in a pair ('single' = float)
% npol      - Number of polarizations (should always be 2 when calc Stokes)
% dformat   - Specifies conversion TO real or complex data
% Nin       - Length of input blocks to be processed
% f_sample_in - Sampling frequency of input data (MHz)
% nseries   - Number input blocks to process
% pfb_type  - Type of PFB: 0 for critically samples, 1 for oversampled
% L         - Number of PFB channels
% Nu        - Numerator of oversampling factor
% De        - Denominator of oversampling factor
% M         - PFB commutator length
% L_M       - PFB overlap length
% chan_no   - selected output channel number to store
%
% OUTPUTS:
% --------
%
% fname_out - Output filename
%
% Changes:
% --------
%
% Author           Date         Comments
% ---------------  -----------  ----------------------------------------
% I. Morrison      31-Jul-2015  Original version
% R. Willcox       07-Sep-2018  Added Over-Sampling factor
%                               Added Header read and write
%
% ----------------------------------------------------------------------
% close all;
% clear all; clc;

% Declare global variables
global L; global M; global L_M; global fname_pfb; global Nu; global De; global ntype;

verbose = 0;
if exist('verbose_', 'var')
  verbose = verbose_;
end

diagnostic_plots = 0;
if exist('diagnostic_plots_', 'var')
  diagnostic_plots = diagnostic_plots_;
end

% current_branch = git_current_branch();

% Output file name
fname_out = strrep(filename_in, 'simulated_pulsar', 'full_channelized_pulsar');

pfb_type = 0;
pfb_str = 'cs';
Nu = 1;
De = 1;
try
  splitInput = strsplit(os_factor,'/'); %what if OS_FACTOR is just 1?
  Nu = str2num(splitInput{1});
  De = str2num(splitInput{2});
catch
end
if (Nu == 1 && De == 1)
    pfb_type = 0; %for CSing
else
    pfb_type = 1; %for OSing
    pfb_str = 'os';
end

split = strsplit(fname_out, '.');
split = [split(1:end-1), pfb_str, split(end)];
fname_out = strjoin(split,'.');
fname_out
%=============
% Default settings for variables that might be found in a header file

hdrsize = 4096; % Header size
npol = 2; % Number of polarizations (should always be 2 when calc Stokes)

% Set bandwidth - default is 8 x 10 MHz, for testing with 8-channel channelizer
f_sample_in = 80; % Sampling frequency of input (MHz)

% Multiplying factor going from input to output type
dformat = 'realtocomplex';
% dformat = 'complextocomplex'; %specifies conversion TO real or complex data
%=============

% Header settings for variables, where they exist
hdr_map = read_header(filename_in, containers.Map());

% Number of polarizations
if isKey(hdr_map,'NPOL') npol = str2num(hdr_map('NPOL')); end

% Set bandwidth
if isKey(hdr_map,'BW') f_sample_in = (-1)*str2num(hdr_map('BW')); end % Sampling frequency of input (MHz)

% set dformat
if isKey(hdr_map, 'NDIM')
  ndim = hdr_map('NDIM');
  switch ndim
    case '1'
      dformat = 'realtocomplex';
    case '2'
      dformat = 'complextocomplex';
  end
end
%=======================================
% Other parameters
hdrtype = 'uint8'; % Data type for header ('uint8' = byte)
ntype = 'single'; % Data type for each element in a pair ('single' = float)
chan_no = 3; % Particular PFB output channel number to store to fill

%=============
% Initialisations

% PFB prototype OS factor and filter coefficients file name
% if pfb_type == 0 % Critically sampled
%     Os = 1;
%     %fname_pfb = 'CS_Prototype_FIR_8.mat';
%     fname_pfb = 'config/OS_Prototype_FIR_8.mat'; % Where is CS_Prototype_FIR.mat?
% else % Over sampled
%     Os = Nu/De; % Oversampling factor
%     fname_pfb = 'config/OS_Prototype_FIR_8.mat';
% end

% Set up parameters depending on whether incoming data is real or complex
switch dformat
    case 'realtocomplex'
        Nmul = 2; % Multiplying factor in converting from real to complex
        NperNin = 1; % 1 data point per polariz per incoming time step
    case 'complextocomplex'
        Nmul = 1;
        NperNin = 2; % 1 real + 1 imag point per pol per incoming time step
    otherwise
        warning('Conversion should be realtocomplex or complextocomplex.');
end


Os = Nu/De;
fname_pfb = 'config/OS_Prototype_FIR_8.mat';
% Number of channels in filter-bank
L= 8;
M = L/Os; % Commutator Length
L_M = L-M; % Overlap
Nin = M*(2^14);  % Number of elements per input file read
output_samples = (Nin/M)/Nmul;

%=============
% Write header data to out files

% update TSAMP in output file
tsamp = str2num(hdr_map('TSAMP'));
tsamp = tsamp*L*(De/Nu)*Nmul;
hdr_map('TSAMP') = tsamp;

% update NDIM to reflect going to complex valued output
hdr_map('NDIM') = '2';
% update NCHAN in output file
hdr_map('NCHAN') = num2str(L);
write_header(fname_out, hdr_map);

%==============
% Prepare for main loop

% Open input file
fid_in = fopen(filename_in);
fread(fid_in, 4096, 'uint8');

% Open output file
% fid_out = fopen(fname_out, 'a');

% Initialise output
y2 = zeros(npol,L,Nin/M,ntype);

% if nseries is -1, figure out how many loops we'll be able to do
if nseries == -1
  s = dir(filename_in);
  input_bytes = s.bytes;
  input_floats = s.bytes / 4; % 4 is number of bytes in 'single' data type
  nseries = floor(input_floats / (npol*Nin*NperNin));
end

% Initial full channelized output,
% for ordering in TFP (Time Frequency Polarization)
% This ordering is required in order to be read by dspsr
y_full_channel = zeros(npol*2, L, (output_samples)*nseries,ntype);
%===============
% Main loop
% Read input blocks and filter
if verbose
  fprintf('header: \n')
  for key=keys(hdr_map)
    fprintf('\t%s: %s\n', key{1}, hdr_map(key{1}));
  end
  fprintf('nseries: %i\n', nseries);
  fprintf('npol: %i\n', npol);
  fprintf('Nin/M: %i\n', Nin/M);
  fprintf('L (number of output channels): %i\n', L);
  fprintf('total datasize: %i\n', npol*2*(Nin/M)*nseries*L);
  fprintf('ntype: %s\n', ntype);
  fprintf('dformat: %s\n', dformat);
  fprintf('oversampling_factor: %d/%d\n',Nu,De);
  fprintf('pfb_type: %d\n', pfb_type);
end

prev_bytes = 1;
for ii=1:nseries
    t0 = cputime;
    for b=1:prev_bytes
      fprintf('\b');
    end
    prev_bytes = fprintf('\nLoop # %i of %i\n', ii, nseries);
    % Print loop number

    % Read stream of voltages into a single column
    Vstream = single(fread(fid_in, npol*Nin*NperNin, ntype));

    if feof(fid_in)
        % error('Error - hit end of input file!');
        fprintf('Done processing input data file!\n')
        break;
        stop = 1;
    end;

    %====================
    % Parse real and imag components if incoming data is complex
    switch dformat
        case 'complextocomplex'
            Vstream = reshape(Vstream, 2, []);
            Vstream = complex(Vstream(1,:), Vstream(2,:));
    end;

    % Separate data into different polarisations: Vdat(1,:) and Vdat(2,:)
    Vdat = reshape(Vstream, npol, []);

    % in the case of real to complex, we have to downsample our data
    size(Vdat);
    if Nmul == 2
      Vdat = Vdat(:,1:2:end);
    end
    size(Vdat);

    if diagnostic_plots
      figure;
      subplot(221); plot((1:Nin),real(Vdat(1,1:Nin))); box on; grid on;
      title('v1 Real');
      subplot(223); plot((1:Nin),imag(Vdat(1,1:Nin))); box on; grid on;
      title('v1 Imag'); xlabel('time');
      subplot(222); plot((1:Nin),real(Vdat(2,1:Nin))); box on; grid on;
      title('v2 Real');
      subplot(224); plot((1:Nin),imag(Vdat(2,1:Nin))); box on; grid on;
      title('v2 Imag'); xlabel('time');
      pause
    end
    % Evaluate the channel outputs
    % First pol
    for n = 1 : output_samples
        if pfb_type == 0
            y2(1,:,n) = CS_PFB_1(Vdat(1,(n-1)*L+1:n*L));
            % pause;
            % if ii == 2
            %   y2(1,:,n)
            %   pause
            % end
        else
            y2(1,:,n) = OS_PFB_1(Vdat(1,(n-1)*M+1:1:n*M));
        end;
    end;
    % Second pol - must use different function due to persistent variables
    for n = 1 : output_samples
        if pfb_type == 0,
            y2(2,:,n) = CS_PFB_2(Vdat(2,(n-1)*L+1:n*L));
        else
            y2(2,:,n) = OS_PFB_2(Vdat(2,(n-1)*M+1:1:n*M));
        end;
    end;

    % Interleave polarizations and real/imag
    % (selecting just the required output channel number)
    % z1_y2(1:output_samples) = y2(1,chan_no,(1:output_samples));
    % z2_y2(1:output_samples) = y2(2,chan_no,(1:output_samples));
    % z = [real(transpose(z1_y2)), imag(transpose(z1_y2)),...
    %      real(transpose(z2_y2)), imag(transpose(z2_y2))];
    % dat = reshape(transpose(z),2*npol*output_samples,1);

    % write data to y_full_channel
    s = (output_samples)*(ii - 1) + 1;
    e = (output_samples)*ii;
    % for c=1:L
    %   y_full_channel(1,c,s:e) = real(y2(1,c,(1:output_samples)));
    %   y_full_channel(2,c,s:e) = imag(y2(1,c,(1:output_samples)));
    %   y_full_channel(3,c,s:e) = real(y2(2,c,(1:output_samples)));
    %   y_full_channel(4,c,s:e) = imag(y2(2,c,(1:output_samples)));
    % end

    y_full_channel(1,:,s:e) = real(y2(1,:,(1:output_samples)));
    y_full_channel(2,:,s:e) = imag(y2(1,:,(1:output_samples)));
    y_full_channel(3,:,s:e) = real(y2(2,:,(1:output_samples)));
    y_full_channel(4,:,s:e) = imag(y2(2,:,(1:output_samples)));

    if diagnostic_plots
      t = (1:output_samples);
      % fig = figure('visible', 'off');
      fig = figure();
      for c=1:L
        for p=1:npol
          for z=1:2
            z_name = 'Real';
            if z == 2
              z_name = 'Imag';
            end

            subplot_idx = z + (p-1)*2 + (c-1)*(npol*2);
            idx = npol*(p - 1) + z;

            y1_plot(1:output_samples) = y_full_channel(idx,c,s:e);
            subplot(L, npol*2, subplot_idx);
            plot(t, y1_plot); box on; grid on;
            title(sprintf('Output %s Pol %i Channel %i', z_name, p, c));
            xlabel('time');
            ax = gca;
            set(ax,'FontSize', 5);
          end
        end
      end
      % fig = gcf;
      % fig.PaperUnits = 'inches';
      % fig.PaperPosition = [0 0 16 9];
      % plt_name = sprintf('products/channelized_data-os_%.2f-%03d.png', Os, ii);
      % print(sprintf('products/channelized_data_%i', ii),'-dpng', '-r150')
      % saveas(fig, plt_name, 'png');
      % print(sprintf('products/channelized_data_%i', ii),'-dsvg'); %, '-r150')
      % pause
    end
    % Write vector to file
    % fwrite(fid_out, dat, ntype);
    if verbose
      prev_bytes = prev_bytes + fprintf('Took %.5f seconds to run loop %d', cputime - t0, ii);
    end
end;

% Open output file for full channelization
fid_out = fopen(fname_out, 'a');
fwrite(fid_out, reshape(y_full_channel, npol*2*L*(output_samples)*nseries, 1), ntype);

fclose(fid_in);
fclose(fid_out);

return

exit();
end


% First CS-PFB
% Critically sampled Polyphase Filter-Bank Channelizer function, based on
% code by Thushara Kanchana Gunaratne, RO/RCO, NSI-NRC, Canada, 2015-03-05
function y = CS_PFB_1(x)

global L; global fname_pfb; global ntype;

%Declaration and Initialization of Input Mask
%As Persistence Variables
persistent n h xM;
if isempty(n)

    %Loading the Prototype Filter as an initiation task
    %This Will NOT repeat in subsequent runs
    FiltCoefStruct = load(fname_pfb);
    h = single(FiltCoefStruct.h);
    %Initiate the Input Mask that is multiplied with the Filter mask
    xM = zeros(1,length(h), ntype);
    %Initiate the Output mask
    yP = zeros(L,1, ntype);
    %Control Index - Initiation
    n = 0;
end; %End if

%Multiplying the Indexed Input Mask and Filter Mask elements and
%accumulating
for k = 1 : L
    yP(k,1) = sum(xM(k:L:end).*h(k:L:end));
end; % For k

%The Linear Shift of Input through the FIFO
%Shift the Current Samples by M to the Right
xM(1,L+1:end) = xM(1,1:end-L);
%Assign the New Input Samples for the first M samples
xM(1,1:L) = fliplr(x);%Note the Flip (Left-Right) place the Newest sample
                      % to the front
%transpose(yP((1:L),1))

% %Evaluating the Cross-Stream (i.e. column wise) IDFT
% yfft = L*L*(ifft(yP));%
%
% %Note the Input Signal is Real-Valued. Hence, only half of the output
% %Channels are Independent. The Packing Method is used here. However,
% %any Optimized Real IFFT Evaluation Algorithm Can be used in its place
% %Evaluating the Cross-Stream (i.e. column wise) IDFT using Packing
% %Method
% %The Complex-Valued Sequence of Half Size
y2C = yP(1:2:end) + 1j*yP(2:2:end);

%The Complex IDFT of LC=L/2 Points
IFY2C = L*L/2*ifft(y2C);
IFY2C;
y(1:L/2) = (0.5*((IFY2C+conj(circshift(flipud(IFY2C),[+1,0])))...
            - 1j*exp(2j*pi*(0:1:L/2-1).'/L).*...
              (IFY2C-conj(circshift(flipud(IFY2C),[+1,0])))));
% [0,+1]
y(L/2+1) = 0.5*((IFY2C(1)+conj(IFY2C(1)) + 1j*(IFY2C(1)-conj(IFY2C(1)))));

y(L/2+2:L) = conj(fliplr(y(2:L/2)));
y;
%Changing the Control Index
n = n+1;

end %Function CS_PFB_1



% Second CS-PFB
% Critically sampled Polyphase Filter-Bank Channelizer function, based on
% code by Thushara Kanchana Gunaratne, RO/RCO, NSI-NRC, Canada, 2015-03-05
function y = CS_PFB_2(x)

global L; global fname_pfb; global ntype;

%Declaration and Initialization of Input Mask
%As Persistence Variables
persistent n h xM;
if isempty(n)

    %Loading the Prototype Filter as an initiation task
    %This Will NOT repeat in subsequent runs
    FiltCoefStruct = load(fname_pfb);
    h = single(FiltCoefStruct.h);

    %Initiate the Input Mask that is multiplied with the Filter mask
    xM = zeros(1,length(h), ntype);
    %Initiate the Output mask
    yP = zeros(L,1, ntype);

    %Control Index - Initiation
    n = 0;

end; %End if

%Multiplying the Indexed Input Mask and Filter Mask elements and
%accumulating
for k = 1 : L
    yP(k,1) = sum(xM(k:L:end).*h(k:L:end));
end; % For k

%The Linear Shift of Input through the FIFO
%Shift the Current Samples by M to the Right
xM(1,L+1:end) = xM(1,1:end-L);
%Assign the New Input Samples for the first M samples
xM(1,1:L) = fliplr(x);%Note the Flip (Left-Right) place the Newest sample
                      % to the front

%transpose(yP((1:L),1))

% %Evaluating the Cross-Stream (i.e. column wise) IDFT
% yfft = L*L*(ifft(yP));%
%
% %Note the Input Signal is Real-Valued. Hence, only half of the output
% %Channels are Independent. The Packing Method is used here. However,
% %any Optimized Real IFFT Evaluation Algorithm Can be used in its place
% %Evaluating the Cross-Stream (i.e. column wise) IDFT using Packing
% %Method
% %The Complex-Valued Sequence of Half Size
y2C = yP(1:2:end) + 1j*yP(2:2:end);
%The Complex IDFT of LC=L/2 Points
IFY2C = L*L/2*ifft(y2C);

y(1:L/2) = (0.5*((IFY2C+conj(circshift(flipud(IFY2C),[+1,0])))...
            - 1j*exp(2j*pi*(0:1:L/2-1).'/L).*...
              (IFY2C-conj(circshift(flipud(IFY2C),[+1,0])))));
% [0,+1]
y(L/2+1) = 0.5*((IFY2C(1)+conj(IFY2C(1)) + 1j*(IFY2C(1)-conj(IFY2C(1)))));

y(L/2+2:L) = conj(fliplr(y(2:L/2)));

%Changing the Control Index
n = n+1;

end %Function CS_PFB_2




% First OS-PFB
% Oversampled Polyphase Filter-Bank Channelizer function, based on code by
% Thushara Kanchana Gunaratne, RO/RCO, NSI-NRC, Canada, 2015-03-05
function y = OS_PFB_1(x)

global L; global Nu; global M; global L_M; global fname_pfb; global ntype;

%Declaration and Initialization of Input Mask
%As Persistance Variables
persistent n h xM;
if isempty(n)
    %Loading the Prototype Filter as an initiation task
    %This Will NOT repeat in subsequent runs
    FiltCoefStruct = load(fname_pfb);
    h = single(FiltCoefStruct.h);

    %Initiate the Input Mask that is multiplied with the Filter mask
    xM = zeros(1,length(h), ntype);
    %Initiate the Output mask
    yP = zeros(L,1, ntype);

    %Control Index - Initiation
    n = 0;

end; %End if

%Multiplying the Indexed Input Mask and Filter Mask elements and
%accumulating
for k = 1 : L
    yP(k,1) = sum(xM(k:L:end).*h(k:L:end));
end; % For k

%The Linear Shift of Input through the FIFO
%Shift the Current Samples by M to the Right
xM(1,M+1:end) = xM(1,1:end-M);
%Assign the New Input Samples for the first M samples
xM(1,1:M) = fliplr(x);%Note the Flip (Left-Right) place the Newest sample
                      % to the front

%Performing the Circular Shift to Compensate the Shift in Band Center
%Frequencies
if n == 0
    y1S = yP;
else
    y1S = [yP((Nu-n)*L_M+1:end); yP(1:(Nu-n)*L_M)];
end;

% %Evaluating the Cross-Stream (i.e. column wise) IDFT
% yfft = L*L*(ifft(yP));%
%
% %Modulating the Channels (i.e. FFT Outputs) to compensate the shift in the
% %center frequency
% %y = yfft.*exp(2j*pi*(1-M/L)*n*(0:1:L-1).');
% y = yfft.*exp(-2j*pi*M/L*n*(0:1:L-1).');

% %Note the Input Signal is Real-Valued. Hence, only half of the output
% %Channels are Independent. The Packing Method is used here. However,
% %any Optimized Real IFFT Evaluation Algorithm Can be used in its place
% %Evaluating the Cross-Stream (i.e. column wise) IDFT using Packing
% %Method
% %The Complex-Valued Sequence of Half Size
y2C = y1S(1:2:end) + 1j*y1S(2:2:end);
%The Complex IDFT of LC=L/2 Points
IFY2C = L*L/2*ifft(y2C);
%
y(1:L/2) = (0.5*((IFY2C+conj(circshift(flipud(IFY2C),[+1,0])))...
            - 1j*exp(2j*pi*(0:1:L/2-1).'/L).*...
             (IFY2C-conj(circshift(flipud(IFY2C),[+1,0])))));
% [0,+1]
y(L/2+1) = 0.5*((IFY2C(1)+conj(IFY2C(1)) + 1j*(IFY2C(1)-conj(IFY2C(1)))));

y(L/2+2:L) = conj(fliplr(y(2:L/2)));

%Changing the Control Index
n = n+1;
n = mod(n,Nu);

end %Function OS_PFB_1



% Second OS-PFB
% Oversampled Polyphase Filter-Bank Channelizer function, based on code by
% Thushara Kanchana Gunaratne, RO/RCO, NSI-NRC, Canada, 2015-03-05
function y = OS_PFB_2(x)

global L; global Nu; global M; global L_M; global fname_pfb; global ntype;

%Declaration and Initialization of Input Mask
%As Persistance Variables
persistent n h xM;
if isempty(n)

    %Loading the Prototype Filter as an initiation task
    %This Will NOT repeat in subsequent runs
    FiltCoefStruct = load(fname_pfb);
    h = single(FiltCoefStruct.h);

    %Initiate the Input Mask that is multiplied with the Filter mask
    xM = zeros(1,length(h), ntype);
    %Initiate the Output mask
    yP = zeros(L,1, ntype);

    %Control Index - Initiation
    n = 0;

end; %End if

%Multiplying the Indexed Input Mask and Filter Mask elements and
%accumulating
for k = 1 : L
    yP(k,1) = sum(xM(k:L:end).*h(k:L:end));
end; % For k

%The Linear Shift of Input through the FIFO
%Shift the Current Samples by M to the Right
xM(1,M+1:end) = xM(1,1:end-M);
%Assign the New Input Samples for the first M samples
xM(1,1:M) = fliplr(x);%Note the Flip (Left-Right) place the Newest sample
                      % to the front

%Performing the Circular Shift to Compensate the Shift in Band Center
%Frequencies
if n == 0
    y1S = yP;
else
    y1S = [yP((Nu-n)*L_M+1:end); yP(1:(Nu-n)*L_M)];
end;

% %Evaluating the Cross-Stream (i.e. column wise) IDFT
% yfft = L*L*(ifft(yP));%
%
% %Modulating the Channels (i.e. FFT Outputs) to compensate the shift in the
% %center frequency
% %y = yfft.*exp(2j*pi*(1-M/L)*n*(0:1:L-1).');
% y = yfft.*exp(-2j*pi*M/L*n*(0:1:L-1).');

% %Note the Input Signal is Real-Valued. Hence, only half of the output
% %Channels are Independent. The Packing Method is used here. However,
% %any Optimized Real IFFT Evaluation Algorithm Can be used in its place
% %Evaluating the Cross-Stream (i.e. column wise) IDFT using Packing
% %Method
% %The Complex-Valued Sequence of Half Size
y2C = y1S(1:2:end) + 1j*y1S(2:2:end);
%The Complex IDFT of LC=L/2 Points
IFY2C = L*L/2*ifft(y2C);
%
y(1:L/2) = (0.5*((IFY2C+conj(circshift(flipud(IFY2C),[+1,0])))...
            - 1j*exp(2j*pi*(0:1:L/2-1).'/L).*...
             (IFY2C-conj(circshift(flipud(IFY2C),[+1,0])))));
% [0,+1]
y(L/2+1) = 0.5*((IFY2C(1)+conj(IFY2C(1)) + 1j*(IFY2C(1)-conj(IFY2C(1)))));

y(L/2+2:L) = conj(fliplr(y(2:L/2)));

%Changing the Control Index
n = n+1;
n = mod(n,Nu);

end %Function OS_PFB_2


% Function to pull observation parameters from a header file
% Also adjusts the TSAMP value to account for Over-Sampling and writes a new header
function hdr_map = headerReadWrite(headerFile, fname_out, hdr_map)

if exist(headerFile, 'file')
    fInputHeaderFile = fopen(headerFile, 'r');
    fid_out = fopen(fname_out, 'a');
    formatSpec = '%c'; %collects all chars
    headerString = fscanf(fInputHeaderFile, formatSpec);
    headerLines = strsplit(headerString, '\n');

    for i=1:length(headerLines)
        % Map parameter names to values
        tempMap = strsplit(headerLines{i}); % Parse lines along whitespace

        % Only consider meaningful lines
        if length(tempMap) > 1
            hdr_map(tempMap{1}) = tempMap{2};

            % TSAMP must be rescaled before appending
            new_line = strcat(headerLines{i},'\n');
            if strcmp(tempMap{1},'TSAMP')
                % Default, if any of TSAMP, NCHAN, OS_FACTOR don't exist
                tsamp_line = new_line;
            else % All lines that are not TSAMP
                fprintf(fid_out, new_line);
            end
        end
    end
    utcnow = datetime('now', 'TimeZone', 'UTC');
    utcnow = datestr(utcnow, 'yyyy-mm-dd-HH:MM:ss');
    hdr_map('UTC_START') = utcnow;
    % Get TSAMP, NCHAN, OS_FACTOR as numbers
    if isKey(hdr_map,'TSAMP')
        tsamp_val = str2num(hdr_map('TSAMP'));

        % Defaults
        nchan_val = 8;
            % PFB downsamples by 8, only outputs 1 of the channels,
            % DSPSR only sees 1 channel, so we can't use NCHAN in the header
        Nu_val = 1;
        De_val = 1;

        % Number of Channels
        if isKey(hdr_map,'NCHAN')
            nchan_val = str2num(hdr_map('NCHAN'));
        end

        % Over-Sampling Factor
        if isKey(hdr_map,'OS_FACTOR')
            splitInput = strsplit(hdr_map('OS_FACTOR'),'/');
            Nu_val = str2num(splitInput{1});
            De_val = str2num(splitInput{2});
        end

        % Fix TSAMP and append
        digitsOld = digits(10); %Increase precision to 10 digits
        tsamp_val = vpa(tsamp_val*nchan_val*De_val/Nu_val); % TSAMP*NCHAN/OS_FACTOR
        tsamp_line = ['TSAMP' '        ' char(tsamp_val) '\n'];
    end

    % Append TSAMP onto output header
    fprintf(fid_out, tsamp_line);

    fclose(fInputHeaderFile);
    fclose(fid_out);
end

return
end % Function headerReadWrite
