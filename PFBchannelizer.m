function PFBchannelizer(filename_in, nseries, os_factor, verbose_, diagnostic_plots_)
  %
  % Takes as input a data file generated by "signalgen.m", passes it through
  % a polyphase filterbank (PFB) channelizer, then stores the output of one
  % channel to file.  The type of PFB is selectable: either critically
  % sampled or oversampled. The number of PFB channels is selectable.
  % The PFB prototype filter is designed separately and its coefficients
  % provided in a file.
  %
  % Inputs:
  % -------
  %
  % filename_in  - Input filename
  % headerFile - A dada-style pulsar signal header file
  % fname_pfb - PFB prototype filter coefficients filename
  %
  % SETTINGS
  %
  % hdrsize   - Header size
  % hdrtype   - Data type for header ('uint8' = byte)
  % ntype     - Data type for each element in a pair ('single' = float)
  % npol      - Number of polarizations (should always be 2 when calc Stokes)
  % dformat   - Specifies conversion TO real or complex data
  % Nin       - Length of input blocks to be processed
  % f_sample_in - Sampling frequency of input data (MHz)
  % nseries   - Number input blocks to process
  % pfb_type  - Type of PFB: 0 for critically samples, 1 for oversampled
  % L         - Number of PFB channels
  % Nu        - Numerator of oversampling factor
  % De        - Denominator of oversampling factor
  % M         - PFB commutator length
  % L_M       - PFB overlap length
  % chan_no   - selected output channel number to store
  %
  % OUTPUTS:
  % --------
  %
  % fname_out - Output filename
  %
  % Changes:
  % --------
  %
  % Author           Date         Comments
  % ---------------  -----------  ----------------------------------------
  % I. Morrison      31-Jul-2015  Original version
  % R. Willcox       07-Sep-2018  Added Over-Sampling factor
  %                               Added Header read and write
  % Dean Shaff       12-Dec-2018  Allow for complex input data
  %                               Got rid of global variables by using closures
  %                               in PFB functions
  % ----------------------------------------------------------------------
  % close all;
  % clear all; clc;

  % Declare global variables
  % global L; global M; global L_M; global fname_pfb; global Nu; global De; global ntype; global NperNin;

  verbose = 0;
  if exist('verbose_', 'var')
    verbose = verbose_;
  end

  diagnostic_plots = 0;
  if exist('diagnostic_plots_', 'var')
    diagnostic_plots = diagnostic_plots_;
  end

  % current_branch = git_current_branch();

  % Output file name
  fname_out = strrep(filename_in, 'simulated_pulsar', 'full_channelized_pulsar');

  pfb_type = 0;
  pfb_str = 'cs';
  Nu = 1;
  De = 1;
  try
    splitInput = strsplit(os_factor,'/'); %what if OS_FACTOR is just 1?
    Nu = str2num(splitInput{1});
    De = str2num(splitInput{2});
  catch
  end
  if (Nu == 1 && De == 1)
      pfb_type = 0; %for CSing
  else
      pfb_type = 1; %for OSing
      pfb_str = 'os';
  end

  split = strsplit(fname_out, '.');
  split = [split(1:end-1), pfb_str, split(end)];
  fname_out = strjoin(split,'.');
  fname_out
  %=============
  % Default settings for variables that might be found in a header file

  hdrsize = 4096; % Header size
  npol = 2; % Number of polarizations (should always be 2 when calc Stokes)

  % Set bandwidth - default is 8 x 10 MHz, for testing with 8-channel channelizer
  f_sample_in = 80; % Sampling frequency of input (MHz)

  % Multiplying factor going from input to output type
  dformat = 'realtocomplex';
  % dformat = 'complextocomplex'; %specifies conversion TO real or complex data
  %=============

  % Header settings for variables, where they exist
  hdr_map = read_header(filename_in, containers.Map());

  % Number of polarizations
  if isKey(hdr_map,'NPOL') npol = str2num(hdr_map('NPOL')); end

  % Set bandwidth
  if isKey(hdr_map,'BW') f_sample_in = (-1)*str2num(hdr_map('BW')); end % Sampling frequency of input (MHz)

  % set dformat
  if isKey(hdr_map, 'NDIM')
    ndim = hdr_map('NDIM');
    switch ndim
      case '1'
        dformat = 'realtocomplex';
      case '2'
        dformat = 'complextocomplex';
    end
  end
  %=======================================
  % Other parameters
  hdrtype = 'uint8'; % Data type for header ('uint8' = byte)
  ntype = 'single'; % Data type for each element in a pair ('single' = float)
  chan_no = 3; % Particular PFB output channel number to store to fill

  %=============
  % Initialisations

  % PFB prototype OS factor and filter coefficients file name
  % if pfb_type == 0 % Critically sampled
  %     Os = 1;
  %     %fname_pfb = 'CS_Prototype_FIR_8.mat';
  %     fname_pfb = 'config/OS_Prototype_FIR_8.mat'; % Where is CS_Prototype_FIR.mat?
  % else % Over sampled
  %     Os = Nu/De; % Oversampling factor
  %     fname_pfb = 'config/OS_Prototype_FIR_8.mat';
  % end

  % Set up parameters depending on whether incoming data is real or complex
  switch dformat
      case 'realtocomplex'
          Nmul = 2; % Multiplying factor in converting from real to complex
          NperNin = 1; % 1 data point per polariz per incoming time step
      case 'complextocomplex'
          Nmul = 1;
          NperNin = 2; % 1 real + 1 imag point per pol per incoming time step
      otherwise
          warning('Conversion should be realtocomplex or complextocomplex.');
  end


  Os = Nu/De;
  % fname_pfb = 'config/OS_Prototype_FIR_8.mat';
  fname_pfb = 'config/Prototype_FIR.mat';
  % Number of channels in filter-bank
  L= 8;
  M = L/Os; % Commutator Length
  L_M = L-M; % Overlap
  Nin = M*(2^14);  % Number of elements per input file read
  output_samples = (Nin/M)/Nmul;
  %=============
  % Write header data to out files

  % make sure oversampling factor is present
  hdr_map('OS_FACTOR') = sprintf('%d/%d', Nu, De);

  % update TSAMP in output file
  tsamp = str2num(hdr_map('TSAMP'));
  tsamp = tsamp*L*(De/Nu)*Nmul;
  hdr_map('TSAMP') = tsamp;

  % update NDIM to reflect going to complex valued output
  hdr_map('NDIM') = '2';
  % update NCHAN in output file
  hdr_map('NCHAN') = num2str(L);
  write_header(fname_out, hdr_map);
  %==============
  % Prepare for main loop

  % Open input file
  fid_in = fopen(filename_in);
  fread(fid_in, 4096, 'uint8');

  % Open output file
  % fid_out = fopen(fname_out, 'a');

  % Initialise output
  y2 = zeros(npol,L,Nin/M,ntype);

  % if nseries is -1, figure out how many loops we'll be able to do
  if nseries == -1
    s = dir(filename_in);
    input_bytes = s.bytes;
    input_floats = s.bytes / 4; % 4 is number of bytes in 'single' data type
    nseries = floor(input_floats / (npol*Nin*NperNin));
  end

  % Initial full channelized output,
  % for ordering in TFP (Time Frequency Polarization)
  % This ordering is required in order to be read by dspsr
  y_full_channel = zeros(npol*2, L, (output_samples)*nseries, ntype);
  %===============
  % Main loop
  % Read input blocks and filter
  if verbose
    fprintf('header: \n')
    for key=keys(hdr_map)
      fprintf('\t%s: %s\n', key{1}, hdr_map(key{1}));
    end
    fprintf('nseries: %i\n', nseries);
    fprintf('npol: %i\n', npol);
    fprintf('Nin/M: %i\n', Nin/M);
    fprintf('L (number of output channels): %i\n', L);
    fprintf('total datasize: %i\n', npol*2*(Nin/M)*nseries*L);
    fprintf('ntype: %s\n', ntype);
    fprintf('dformat: %s\n', dformat);
    fprintf('oversampling_factor: %d/%d\n',Nu,De);
    fprintf('pfb_type: %d\n', pfb_type);
  end

  prev_bytes = 1;

  pfb_func = {PFB_factory(L, fname_pfb, Nu, De, NperNin, ntype, verbose),...
              PFB_factory(L, fname_pfb, Nu, De, NperNin, ntype, verbose)};

  for ii=1:nseries
      t0 = cputime;
      for b=1:prev_bytes
        fprintf('\b');
      end
      prev_bytes = fprintf('\nLoop # %i of %i\n', ii, nseries);
      % Print loop number

      % Read stream of voltages into a single column
      Vstream = single(fread(fid_in, npol*Nin*NperNin, ntype));

      if feof(fid_in)
          % error('Error - hit end of input file!');
          fprintf('Done processing input data file!\n')
          break;
          stop = 1;
      end;

      %====================
      % Parse real and imag components if incoming data is complex
      switch dformat
          case 'complextocomplex'
              Vstream = reshape(Vstream, 2*npol, []);
              size_Vstream = size(Vstream);
              Vdat = zeros(npol, size_Vstream(end));
              Vdat(1, :) = complex(Vstream(1,:), Vstream(2,:));
              Vdat(2, :) = complex(Vstream(3,:), Vstream(4,:));
              % Vdat = squeeze(complex(Vdat(:,1,:), Vdat(:,2,:)));
              % Vstream = reshape(Vstream, 2, []);
              % Vstream = complex(Vstream(1,:), Vstream(2,:));
              % Vdat = reshape(Vdat, 2, []);
              % Vdat = complex(Vdat(1,:), Vdat(2,:));
            case 'realtocomplex'
              Vdat = squeeze(reshape(Vstream, npol, []));
      end;

      % % Separate data into different polarisations: Vdat(1,:) and Vdat(2,:)
      % Vdat = reshape(Vstream, npol, []);

      % in the case of real to complex, we have to downsample our data
      if Nmul == 2
        Vdat = Vdat(:,1:2:end);
      end

      if diagnostic_plots
        figure;
        subplot(221); plot((1:Nin),real(Vdat(1,1:Nin))); box on; grid on;
        title('v1 Real');
        subplot(223); plot((1:Nin),imag(Vdat(1,1:Nin))); box on; grid on;
        title('v1 Imag'); xlabel('time');
        subplot(222); plot((1:Nin),real(Vdat(2,1:Nin))); box on; grid on;
        title('v2 Real');
        subplot(224); plot((1:Nin),imag(Vdat(2,1:Nin))); box on; grid on;
        title('v2 Imag'); xlabel('time');
        pause
      end
      % Evaluate the channel outputs
      chunk_size = L;
      if pfb_type == 1
        chunk_size = M;
      end

      for p = 1:npol
      % for p = fliplr(1:npol)
        % fprintf('pol: %d', p);
        pfb = pfb_func{p};
        for n = 1:output_samples
          res = pfb(Vdat(p,(n-1)*chunk_size+1:n*chunk_size));
          y2(p,:,n) = res;
        end
      end

      % for n = 1 : output_samples
      %     if pfb_type == 0
      %         y2(1,:,n) = CS_PFB_1(Vdat(1,(n-1)*L+1:n*L));
      %     else
      %         y2(1,:,n) = OS_PFB_1(Vdat(1,(n-1)*M+1:1:n*M));
      %     end;
      % end;
      % % Second pol - must use different function due to persistent variables
      % for n = 1 : output_samples
      %     if pfb_type == 0,
      %         y2(2,:,n) = CS_PFB_2(Vdat(2,(n-1)*L+1:n*L));
      %     else
      %         y2(2,:,n) = OS_PFB_2(Vdat(2,(n-1)*M+1:1:n*M));
      %     end;
      % end;

      % Interleave polarizations and real/imag
      % (selecting just the required output channel number)
      % z1_y2(1:output_samples) = y2(1,chan_no,(1:output_samples));
      % z2_y2(1:output_samples) = y2(2,chan_no,(1:output_samples));
      % z = [real(transpose(z1_y2)), imag(transpose(z1_y2)),...
      %      real(transpose(z2_y2)), imag(transpose(z2_y2))];
      % dat = reshape(transpose(z),2*npol*output_samples,1);

      % write data to y_full_channel
      s = (Nmul*output_samples)*(ii - 1) + 1;
      e = (Nmul*output_samples)*ii;
      % for c=1:L
      %   y_full_channel(1,c,s:e) = real(y2(1,c,(1:output_samples)));
      %   y_full_channel(2,c,s:e) = imag(y2(1,c,(1:output_samples)));
      %   y_full_channel(3,c,s:e) = real(y2(2,c,(1:output_samples)));
      %   y_full_channel(4,c,s:e) = imag(y2(2,c,(1:output_samples)));
      % end
      % size(y_full_channel(1, :, s:e))
      % size(y2)
      y_full_channel(1,:,s:e) = real(y2(1,:,:));
      y_full_channel(2,:,s:e) = imag(y2(1,:,:));
      y_full_channel(3,:,s:e) = real(y2(2,:,:));
      y_full_channel(4,:,s:e) = imag(y2(2,:,:));

      % y_full_channel(1,:,s:e) = real(y2(1,:,:));
      % y_full_channel(2,:,s:e) = real(y2(2,:,:));
      % y_full_channel(3,:,s:e) = imag(y2(1,:,:));
      % y_full_channel(4,:,s:e) = imag(y2(2,:,:));

      % y_full_channel(1,:,s:e) = real(y2(1,:,1:output_samples));
      % y_full_channel(2,:,s:e) = imag(y2(1,:,1:output_samples));
      % y_full_channel(3,:,s:e) = real(y2(2,:,1:output_samples));
      % y_full_channel(4,:,s:e) = imag(y2(2,:,1:output_samples));

      if diagnostic_plots
        t = (1:output_samples);
        % fig = figure('visible', 'off');
        fig = figure();
        for c=1:L
          for p=1:npol
            for z=1:2
              z_name = 'Real';
              if z == 2
                z_name = 'Imag';
              end

              subplot_idx = z + (p-1)*2 + (c-1)*(npol*2);
              idx = npol*(p - 1) + z;

              y1_plot(1:output_samples) = y_full_channel(idx,c,s:e);
              subplot(L, npol*2, subplot_idx);
              plot(t, y1_plot); box on; grid on;
              title(sprintf('Output %s Pol %i Channel %i', z_name, p, c));
              xlabel('time');
              ax = gca;
              set(ax,'FontSize', 5);
            end
          end
        end
        % fig = gcf;
        % fig.PaperUnits = 'inches';
        % fig.PaperPosition = [0 0 16 9];
        % plt_name = sprintf('products/channelized_data-os_%.2f-%03d.png', Os, ii);
        % print(sprintf('products/channelized_data_%i', ii),'-dpng', '-r150')
        % saveas(fig, plt_name, 'png');
        % print(sprintf('products/channelized_data_%i', ii),'-dsvg'); %, '-r150')
        % pause
      end
      % Write vector to file
      % fwrite(fid_out, dat, ntype);
      if verbose
        prev_bytes = prev_bytes + fprintf('Took %.5f seconds to run loop %d', cputime - t0, ii);
      end
  end;

  % Open output file for full channelization
  fid_out = fopen(fname_out, 'a');
  fwrite(fid_out, reshape(y_full_channel, npol*2*L*(Nmul*output_samples)*nseries, 1), ntype);

  fclose(fid_in);
  fclose(fid_out);

  return

  exit();
  end


  function PFB = CS_PFB_factory(Nchan, pfb_filter_coef_fname, output_ndim_, ntype_)

    output_ndim = 1;
    if exist(output_ndim_, 'var')
      output_ndim = output_ndim_;
    end

    ntype = 'single';
    if exist(ntype_, 'var')
      ntype = ntype_;
    end

    L = Nchan;

    FiltCoefStruct = load(pfb_filter_coef_fname);
    h = single(FiltCoefStruct.h);

    %Initiate the Input Mask that is multiplied with the Filter mask
    xM = zeros(1,length(h), ntype);
    %Initiate the Output mask
    yP = zeros(L, 1, ntype);
    %Control Index - Initiation
    n = 0;

    PFB = @CS_PFB;

  end


function PFB = PFB_factory(Nchan, pfb_filter_coef_fname, OS_Nu, OS_De, output_ndim_, ntype_, verbose_)

  if OS_Nu == OS_De
    pfb_type = 0;
  else
    pfb_type = 1;
  end

  Os = OS_Nu/OS_De;
  L = Nchan;
  M = L/Os;
  L_M = L-M;

  output_ndim = 1;
  if exist('output_ndim_', 'var')
    output_ndim = output_ndim_;
  end

  ntype = 'single';
  if exist('ntype_', 'var')
    ntype = ntype_;
  end

  verbose = 0;
  if exist('verbose', 'var')
    verbose = verbose_;
  end

  if verbose
    fprintf('PFB_factory: output_ndim: %d\n', output_ndim);
    fprintf('PFB_factory: ntype: %s\n', ntype);
  end


  FiltCoefStruct = load(pfb_filter_coef_fname);
  h = single(FiltCoefStruct.h);

  %Initiate the Input Mask that is multiplied with the Filter mask
  xM = zeros(1,length(h), ntype);
  %Initiate the Output mask
  yP = zeros(L, 1, ntype);
  %Control Index - Initiation
  n = 0;

  if pfb_type == 0
    if verbose
      fprintf('PFB_factory: Using critically sampled PFB\n');
    end
    PFB = @CS_PFB;
  elseif pfb_type == 1
    if verbose
      fprintf('PFB_factory: Using oversampled sampled PFB\n');
    end
    PFB = @OS_PFB;
  end

  function y = CS_PFB(x)
    %Multiplying the Indexed Input Mask and Filter Mask elements and
    %accumulating
    for k = 1 : L
        yP(k,1) = sum(xM(k:L:end).*h(k:L:end));
    end; % For k
    %The Linear Shift of Input through the FIFO
    %Shift the Current Samples by M to the Right
    xM(1,L+1:end) = xM(1,1:end-L);
    %Assign the New Input Samples for the first M samples
    xM(1,1:L) = fliplr(x);%Note the Flip (Left-Right) place the Newest sample
                          % to the front
    %transpose(yP((1:L),1))
    %Performing the Circular Shift to Compensate the Shift in Band Center
    %Frequencies
    y1S = yP;
    % if n == 0
    %     y1S = yP;
    % else
    %     y1S = [yP((Nchan-n)+1:end); yP(1:(Nchan-n))];
    % end;

    % yP
    % n
    % xM
    % pause;

    % %Evaluating the Cross-Stream (i.e. column wise) IDFT
    % yfft = L*L*(ifft(yP));%
    %
    % %Note the Input Signal is Real-Valued. Hence, only half of the output
    % %Channels are Independent. The Packing Method is used here. However,
    % %any Optimized Real IFFT Evaluation Algorithm Can be used in its place
    % %Evaluating the Cross-Stream (i.e. column wise) IDFT using Packing
    % %Method
    % %The Complex-Valued Sequence of Half Size
    y2C = y1S(1:2:end) + 1j*y1S(2:2:end);

    if output_ndim == 1
      %The Complex IDFT of LC=L/2 Points
      IFY2C = L*L/2*ifft(y2C);
      IFY2C;
      y(1:L/2) = (0.5*((IFY2C+conj(circshift(flipud(IFY2C),[+1,0])))...
                  - 1j*exp(2j*pi*(0:1:L/2-1).'/L).*...
                    (IFY2C-conj(circshift(flipud(IFY2C),[+1,0])))));
      % [0,+1]
      y(L/2+1) = 0.5*((IFY2C(1)+conj(IFY2C(1)) + 1j*(IFY2C(1)-conj(IFY2C(1)))));

      y(L/2+2:L) = conj(fliplr(y(2:L/2)));
    elseif output_ndim == 2
      y = L*L*ifft(y1S);
      % y = L*fft(y1S); % have to use inverse fft
    end
    %Changing the Control Index
    n = n+1;
    n = mod(n, Nchan);
  end


  function y = OS_PFB(x)

    %Multiplying the Indexed Input Mask and Filter Mask elements and
    %accumulating
    for k = 1 : L
        yP(k,1) = sum(xM(k:L:end).*h(k:L:end));
    end; % For k

    %The Linear Shift of Input through the FIFO
    %Shift the Current Samples by M to the Right
    xM(1,M+1:end) = xM(1,1:end-M);
    %Assign the New Input Samples for the first M samples
    xM(1,1:M) = fliplr(x);%Note the Flip (Left-Right) place the Newest sample
                          % to the front

    %Performing the Circular Shift to Compensate the Shift in Band Center
    %Frequencies
    if n == 0
        y1S = yP;
    else
        y1S = [yP((OS_Nu-n)*L_M+1:end); yP(1:(OS_Nu-n)*L_M)];
    end;

    % %Evaluating the Cross-Stream (i.e. column wise) IDFT
    % yfft = L*L*(ifft(yP));%
    %
    % %Modulating the Channels (i.e. FFT Outputs) to compensate the shift in the
    % %center frequency
    % %y = yfft.*exp(2j*pi*(1-M/L)*n*(0:1:L-1).');
    % y = yfft.*exp(-2j*pi*M/L*n*(0:1:L-1).');

    % %Note the Input Signal is Real-Valued. Hence, only half of the output
    % %Channels are Independent. The Packing Method is used here. However,
    % %any Optimized Real IFFT Evaluation Algorithm Can be used in its place
    % %Evaluating the Cross-Stream (i.e. column wise) IDFT using Packing
    % %Method
    % %The Complex-Valued Sequence of Half Size
    if output_ndim == 1
      y2C = y1S(1:2:end) + 1j*y1S(2:2:end);
      %The Complex IDFT of LC=L/2 Points
      IFY2C = L*L/2*ifft(y2C);
      %
      y(1:L/2) = (0.5*((IFY2C+conj(circshift(flipud(IFY2C),[+1,0])))...
                  - 1j*exp(2j*pi*(0:1:L/2-1).'/L).*...
                   (IFY2C-conj(circshift(flipud(IFY2C),[+1,0])))));
      % [0,+1]
      y(L/2+1) = 0.5*((IFY2C(1)+conj(IFY2C(1)) + 1j*(IFY2C(1)-conj(IFY2C(1)))));

      y(L/2+2:L) = conj(fliplr(y(2:L/2)));
    elseif output_ndim == 2
      y = L*L*ifft(y1S);
      % y = L*fft(y1S);
    end
    %Changing the Control Index
    n = n+1;
    n = mod(n, OS_Nu);

  end
end
